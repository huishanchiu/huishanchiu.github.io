[{"path":"/2024/11/07/Webpack-5-學習筆記/","content":"Webpack本篇為參考 freeCodeCamp 的教學影片的實做筆記，如有錯誤歡迎指正！ webpack 是什麼？ 一種前端資源構建工具 當在 html 引入 scss 等 css 預處理器，瀏覽器不認識，需要另外把 scss 轉成 css 當寫的 js 引用 ES6 或更高的語法，瀏覽器有可能不認識，需要另外把語法編譯成瀏覽器懂的 因此發展出「構建工具」來幫我們管理這些細瑣的編譯小工具幫我們把不同的檔案打包壓縮成一個 bundle 一種靜態模塊打包工具 在寫 js 時我們可能會引入其他不同的套件(JQ、scss…統稱靜態模塊)，webpack 幫我們把不同套件形成 chunk(代碼塊) 再將 chunk 進行處理，如把 scss 編譯成 css 根據模塊的依賴關係進行靜態分析，打包生成靜態資源- bundle webpack 五個核心概念 Entry：告訴 webpack 以哪個文件為入口開始打包，並分析內部的依賴 Output：告訴 webpack 打包後的資源 bundles 要輸出到哪裡，及如何命名 Loader：webpack 本身只能理解 js &amp; JSON，Loader 像翻譯官把 css 等翻譯成 js Plugins：指定插件能執行範圍更廣的任務，比如壓縮 Mode：development &amp; production可以針對 dev、prod 環境分別制定不同規則，例如 prod 的打包後的 bundle 想要加入 [hashContent]來命名，dev 則不需要…等等 commit 1:First commit我是參考 freeCodeCamp 的教學影片一步步實做，由於現在 webpack 版本的更新，已經有很多功能不需要安裝額外的插件就能做到了 commit 2: Break code into separate scripts拆分代碼，把函式提取出來 commit 3: Installed webpack npm init → 初始化一個新的 Node.js 專案。它會幫助你建立一個基本的 package.json 文件，該文件包含專案的元數據，例如專案名稱、版本、描述、入口點、腳本、依賴項等 package.json123456&#123; &quot;name&quot;: &quot;webpack-demo-app&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;private&quot;: true, // 防止此專案被意外發佈到 npm 公共列表裡讓他人安裝 ...&#125; 安裝 webpack 和 webpack-cli npm install --save-dev webpack webpack-cli webpack-cli 是 Webpack 的命令行工具（Command Line Interface），用來幫助開發者通過命令行（terminal 或 command prompt）執行 Webpack 的各種功能 --save-dev 因為 webpack 屬於開發工具，是安裝到 devDependencies 裡，也可以寫成 -D package.json 123456&#123; &quot;name&quot;: &quot;webpack-demo-app&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;private&quot;: true, &quot;scripts&quot;: &#123;&quot;start&quot;: &quot;webpack&quot;&#125;,&#125; 執行 webpack 1npm start 此時會報錯，ERROR in Entry module not found: Error: Can&#39;t resolve &#39;./src&#39; in &#39;your-directory/webpack-demo-app&#39;。發現在 ./src 這個資料夾找不到 index.js，所以在 ./src 這個資料夾下建立 index.js 後再試一次 npm start 看看編譯的狀況。 剛剛的 error 消失，這時顯示一個警告，設定檔中的模式參數 mode 未設定 ，稍後會建立設定檔來解決 123WARNING in configurationThe &#x27;mode&#x27; option has not been set, webpack will fallback to &#x27;production&#x27; for this value. Set &#x27;mode&#x27; option to &#x27;development&#x27; or &#x27;production&#x27; to enable defaults for each environment.You can also set it to &#x27;none&#x27; to disable any default behavior. Learn more: https://webpack.js.org/configuration/mode/ 不過此時已經可以看到有新的 dist 文件夾，裡面多了一個 main.js，這時在 index.html 多引入 123456&lt;script src=&quot;./src/app/alert.service.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./src/app/component.service.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./src/app/utils/inputs-are-valid.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./src/app/utils/parse-inputs.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./src/app/app.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./dist/main.js&quot;&gt;&lt;/script&gt;✅ 重整後就可以看到來自 index.js 裡的訊息了～ commit 4:Use webpack bundle the codeES6 (2015)引進模組系統，使用import、export 來匯入、導出模組，讓開發者可以將 JavaScript 程式碼模組化 因為將每隻 JS 都包進了入口點：main.js 裡，所以可以將 index.html 裡原本的 js 們刪除，只留下 ./dist/main.js commit 5:Add webpack config filepackage.json 123&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack --config webpack.config.js&quot; &#125;, 就能執行 webpack.config.js commit 6:Add Sass loader and override boostrap colorbackground: webpack only understands JavaScript and JSON files css-loader 把 css 檔案裡的內容轉為合法的 js style-loader 獲取 css 轉換後的 js 並注入到 DOM 裡 commit 7將原本在 html 裡的 bootstrap 移除，改成安裝 bootstrap main.css→main.scss 安裝 sass.loader commit 8:Add Sass loader and override boostrap color處理瀏覽器快取問題，因為 main.js 的名字一直都相同，有可能在檔案內容有改變，卻被瀏覽器快取住舊版本檔案，因此要在每次檔案內容有改變時都生成新的名字防止瀏覽器快取 安裝 webpack plgins 1npm install --save-dev html-webpack-plugin 他會幫我們在 dist 資料夾產生一個 html 這時有成功生成 index.html，但他並沒有包含我們原始的 html 內容 所以要在 src 下創一個新的 template.html ，把原有的 html 內容貼上來 webpack.config 中指定 12345plugins: [ new HtmlWebpackPlugin(&#123; template: &quot;./src/template.html&quot;, &#125;),], commit 9:Add prod and dev configs, add dev-serverSplit webpack.config to dev and prod env將 webpack config 分成 common、正式、測試環境 使用 webpack-merge 將三者結合起來 安裝 webpack-merge 1npm install --save-dev webpack-merge ＊注意引用時要寫這樣，否則會找不到 1const &#123; merge &#125; = require(&quot;webpack-merge&quot;); 在 package.json 裡的 script 定義 start、build 分別要使用哪個 webpack 檔案 1234&quot;scripts&quot;:&#123; &quot;start&quot;:&quot;webpack --config webpack.dev.js&quot; &quot;build&quot;:&quot;webpack --config webpack.prod.js&quot;&#125; 安裝 webpack-dev-server 1npm install --save-dev webpack-dev-server 1234&quot;scripts&quot;:&#123; &quot;start&quot;:&quot;webpack-dev-server --config webpack.dev.js --open&quot; &quot;build&quot;:&quot;webpack --config webpack.prod.js&quot;&#125; commit 10:Add html-loaderhtml-loader圖片不顯示（webpack 無法解析圖片）—&gt;使用 html-loader 123npm install --save-dev html-loader// ornpm i -D html-loader 在 webpack.commom 新增一條 rule 1234&#123; test: /\\.html$/, use: [&quot;html-loader&quot;], // 讓 webpack 可以解析 html 內容&#125;, 此時下 npm run build，會發現 dist 裡面多了打包過的圖檔，而 index.html 裡也是使用這個打包後的 svg 接下來嘗試用 file-loader 指定圖片 output 的路徑 1npm i -D file-loader 並新增 rule—&gt;以前做法(發現發生重複打包) 12345678910&#123; test: /\\.(svg|png|jpg|gif)$/, use:&#123; loader: &quot;file-loader&quot;, options:&#123; name:&quot;[name].[hash].[ext]&quot;, outputPath: &quot;imgs&quot; &#125; &#125;&#125;, 在 webpack 5，可以不需要安裝 file-loader，可以直接這樣寫 12345678&#123; test: /\\.(svg|png|jpg|gif)$/, type: &quot;asset/resource&quot;, generator: &#123; filename: &quot;imgs/[name].[hash][ext]&quot;, &#125;, &#125;, clean-webpack-plugin—&gt;現在也不需要了每次當 npm run build 時，如果內容不同，就會產出一份 main.[xxx].js，以防檔案越來越多，所以安裝 clean-webpack-plugin 來確保每次在 dist 裡的 main.[xxx].js 都只有一份當下的 12345678module.exports = merge(common, &#123; mode: &quot;production&quot;, output: &#123; filename: &quot;main.[contentHash].js&quot;, path: path.resolve(__dirname, &quot;dist&quot;), clean: true, // 加上這個就好 &#125;,&#125;); commit 11:Add entrypoint for vendor.js, add boostrap js拆分不同 budle 在 webpack.common 加入其他進入點 1234entry: &#123; main: &quot;./src/index.js&quot;, vendor: &quot;./src/vendor.js&quot;, &#125;, 再分別到 webpack.prod、dev 設定 bundle output 的名字 123456789// webpack.devmodule.exports = merge(common, &#123; mode: &quot;production&quot;, output: &#123; filename: &quot;[name].bubdle.js&quot;, // 在檔案有更新時會生成不同名字的 js 防止瀏覽器快取 path: path.resolve(__dirname, &quot;dist&quot;), // 打包後的檔案應該儲存的位置，__dirname:當前檔案所在的目錄 clean: true, &#125;,&#125;); 123456789// webpack.prodmodule.exports = merge(common, &#123; mode: &quot;production&quot;, output: &#123; filename: &quot;[name].[contentHash].bundle.js&quot;, // 在檔案有更新時會生成不同名字的 js 防止瀏覽器快取 path: path.resolve(__dirname, &quot;dist&quot;), // 打包後的檔案應該儲存的位置，__dirname:當前檔案所在的目錄 clean: true, &#125;,&#125;); 執行 npm run build 檢查產生出的 index.html 是否包含這兩隻 bundle js"},{"title":"JS中的非同步","path":"/2024/06/20/JS中的非同步/","content":"意思是每件事情不依賴彼此結束才進行，例如在網頁中向伺服器發出請求，在等待的時間不會阻塞其他進程 像這樣處理事件的流程不會被「卡住」，就是非同步 (Asynchronous) 的概念。 JS 是單執行緒的語言，為了處理非同步問題，因此發展了事件循環為了實現非同步可以用以下三個方法： Callback123456789101112131415161718var funcA = function () &#123; var i = Math.random() + 1; window.setTimeout(function () &#123; console.log(&quot;function A&quot;); &#125;, i * 1000);&#125;;var funcB = function () &#123; var i = Math.random() + 1; window.setTimeout(function () &#123; console.log(&quot;function B&quot;); &#125;, i * 1000);&#125;;funcA();funcB(); 在這個範例中，我們讓兩個 fn 隨意的 setTimeout ，所以我們無法預測 function A、function B 誰先出現 過去常見的做法，會將後續要做的事透過參數的方式傳給另一個函式，以確保在原本的函式執行後才去呼叫 1234567891011121314151617181920212223var funcA = function (callback) &#123; var i = Math.random() + 1; window.setTimeout(function () &#123; console.log(&quot;function A&quot;); // 如果 callback 是個函式就呼叫它 if (typeof callback === &quot;function&quot;) &#123; callback(); &#125; &#125;, i * 1000);&#125;;var funcB = function () &#123; var i = Math.random() + 1; window.setTimeout(function () &#123; console.log(&quot;function B&quot;); &#125;, i * 1000);&#125;;// 為了確保先執行 funcA 再執行 funcB, 呼叫 funcA() 的時候，將 funcB 作為參數帶入funcA(funcB); 所以當有太多需要固定「回去呼叫」的函式時，就可能出現 callback hell Promise 在 HTML5 的 WebAPI 標準中，event loop 新增了微任務序列（micro task queue），Promise 正是透過微任務序列來驅動的 微任務觸發時機：在 Stack 清空時，JavaScript 引擎會先確認微任務序列有沒有東西，有的話就優先執行，直到清空後，才從 Queue 拿出新任務到 Stack 上 Why Promise?為了避免 callback hell，ES6 以後為了解決同步&#x2F;非同步問題，新增了一個特殊物件-promise What is Promise?按字面翻譯就是「承諾、約定」的意思，回傳結果有完成或是拒絕； Promise 物件有三種狀態： pending &#x2F; fulfilled &#x2F; rejected 當 Promise 被完成時，我們可以呼叫 resolve()，將取得的資料傳遞出去要提供一個函式 promise 功能，讓它回傳一個 promise 物件即可： 12345function myAsyncFunction(url) &#123; return new Promise((resolve, reject) =&gt; &#123; // resolve() or reject() &#125;);&#125; 延續 Callback 裡的例子，可以這樣改寫成 Promise： 123456789101112131415161718192021222324252627282930313233var funcA = function () &#123; return new Promise((resolve, reject) =&gt; &#123; var i = Math.random() + 1; setTimeout(function () &#123; console.log(&quot;function A&quot;, i); resolve(&quot;A&quot;); &#125;, i * 1000); &#125;);&#125;;var funcB = function () &#123; return new Promise((resolve, reject) =&gt; &#123; var i = Math.random() + 1; setTimeout(function () &#123; console.log(&quot;function B&quot;, i); resolve(&quot;B&quot;); &#125;, i * 1000); &#125;);&#125;;funcA().then(funcB);// 若想接到 funcA/funcB 裡的結果funcA() .then((res) =&gt; &#123; console.log(&quot;res&quot;, res); return funcB(); &#125;) .then((resB) =&gt; &#123; console.log(&quot;resB&quot;, resB); console.log(&quot;全都好了&quot;); &#125;); 就可以達成等到 funcA 被 resolve 再執行 funcB如果不在乎 funcA, funcB 誰先誰後，可以用 promise.all() 123Promise.all([funcA, funcB]).then(() =&gt; &#123; console.log(&quot;全都好了！&quot;);&#125;); async&#x2F;await一年過去，ES7 規範了新的 async&#x2F;await（promise 的語法糖） 一樣來改寫上一個 promise 的範例： 1234567891011121314151617181920212223242526var funcA = function () &#123; return new Promise((resolve, reject) =&gt; &#123; var i = Math.random() + 1; setTimeout(function () &#123; console.log(&quot;function A&quot;, i); resolve(); &#125;, i * 1000); &#125;);&#125;;var funcB = function () &#123; return new Promise((resolve, reject) =&gt; &#123; var i = Math.random() + 1; setTimeout(function () &#123; console.log(&quot;function B&quot;, i); resolve(&quot;B&quot;); &#125;, i * 1000); &#125;);&#125;;async function main() &#123; await funcA(); await funcB(); console.log(&quot;全都好了&quot;);&#125; 在最後呼叫 funcA &amp; funcB 前都加上 await ，就可以確保 funcA 完成 →funcB 完成 → 印出 console","categories":["JS"]},{"title":"深拷貝與淺拷貝","path":"/2024/05/02/深拷貝與淺拷貝/","content":"為什麼需要這個？是為解決什麼問題？ 解決物件&#x2F;陣列的拷貝問題 各自的使用場景 淺拷貝 → 當今天資料只有一層時，使用淺拷貝可以更輕量、不消耗太多資源的進行拷貝，它只複製最外層的結構，而不涉及內部對象的複製，這樣可以節省時間和資源 深拷貝 → 我們需要一個完全獨立的副本而不想修改到原始資料時，可以使用深拷貝 狀況一、物件沒有被實際拷貝 12345let a = [1, 2];let b = a; // 沒有建立新物件，參考到同一個物件實體b[0] = 3;console.log(a); //[3,2] 狀況二、物件拷貝 → 兩物件之間無關連性了 12345let a = [1, 2];let b = [...a]; // 建立新物件，並複製原物件的資料b[0] = 3;console.log(a); //[1,2] 淺拷貝 Shallow copy 僅「真正」拷貝物件的第一層資料 僅第一層會是不同的參考 常見的拷貝工具都是淺拷貝 1234567891011let a = &#123; x: 1, y: 2, data: [3, 4, 5],&#125;;let b = &#123; ...a &#125;;let c = Object.assign([], a);b.data[0] = 30;console.log(a.data[0]); // 30 →原本的 a 被改變了 深拷貝 Deep copy 完全拷貝物件底下「所有」層次的資料 建立兩個完全獨立的物件實體 方法一：JSON.parse(JSON.stringify(…)) 使用 JS 內建方法 JSON.stringify() 將物件字串化（序列化 Serialize） 使用 JSON.parse() 根據字串化的資料重新建立物件結構，完成深拷貝 123456789let a = &#123; x: 1, y: 2, data: [3, 4, 5],&#125;;let b = JSON.parse(JSON.stringify(a));b.data[0] = 30;console.log(a.data[0]); // 3 →原本的 a 沒有被改變了 &#x3D;&#x3D;JSON 方法的限制&#x3D;&#x3D; 無法拷貝不能字串化的資料 無法拷貝函式或是 symbol 等資料 方法二：structuredClone使用 JS 內建方法 structuredClone 12345678910let a = &#123; x: 1, y: 2, data: [3, 4, 5],&#125;;let b = structuredClone(a);b.x = 200;console.log(&quot;a&quot;, a.x); //1console.log(&quot;b&quot;, b.x); //200 方法三：遞迴建立 deepCopy function 思考： 利用 typeof 判斷傳進來的物件是否為 object 若不是，代表沒有需要拆解的第二層資料 →return 若是，繼續呼叫 deepCopy 123456789101112131415161718192021222324252627282930function deepCopy(obj)&#123; // 1.檢查是否為物件，如果不是，直接返回 if(typeof obj !== &quot;object&quot;&amp;&amp; obj !== null)&#123; return &#125; // 2.創建一個新的空物件或陣列，根據原始物件的類型 const newObj = Array.isArray(obj):[]?&#123;&#125; // 3.遞迴複製原始物件的每個屬性或元素 for(let key in obj)&#123; // 進行拷貝（單維的 shallow copy 會建立兩個實體） // js object bracket notation // const c = &#123;x:10,y:20&#125; // console.log(c[&quot;y&quot;])//20 newObj[key] = deepCopy(obj[key]) &#125; return newObj&#125;let a = &#123; x:1, y:2, data:[3,4,5]&#125;let b =deepCopy(a);b.data[0] = 30console.log(a.data[0] )// 3 完成深拷貝！","categories":["JS"]},{"title":"轉職起點-AppWorks School申請心得分享","path":"/2024/05/02/轉職起點-AppWorks-School申請心得分享/","content":"在發現寫程式這件事似乎可以透過線上自學、參與實體課程來訓練後，我查詢了許多線上課程與 coding camp，最終決定在今年申請 AppWorks School，最大的因素是因為 AppWorks 在網路界具有一定的名聲，在爬文時看到很多人都對其畢業校友有良好的印象，錄取率也相對高，雖然知道競爭激烈 (錄取率約莫 10%)，但如果真的要轉職，那值得努力準備一番，讓轉職起點多一點信心。 而今年（2020）二月剛好是 Batch 13 的開學日，根據往年的經驗下一期應該會落在五、六月，於是我就一面上班、一面開始上網爬文畢業校友的心得、也一邊上一些線上課程確定自己喜不喜歡寫程式這件事，接下來我會分享我在準備申請資料的過程中做了哪些，以及覺得可以更好的地方。 我做了哪些我的策略就是，每一題都用力地的回答！（笑） 首先我把網路上有申請經驗的分享文章都看了一遍，不管是有申請上或是面試後沒通過的筆友們都有值得參考的地方，從中我歸納出大致書審資料會問的問題，最重要的不外乎是轉職動機、曾經自學過的經驗以及一分鐘的自我介紹影片 (optional) 等問題，文章末我會附上完整的題目供大家參考。雖然有些題目是選填，但我認為一些能夠展現個人特質的題目一定要把握，像自我介紹影片雖然跟寫程式沒有關係，但卻是很好展現自我的加分題。 再來就是，把你想做的事告訴身邊的朋友吧！在查找資料階段意外發現跟我同大學不同系的同學、同事的姊姊以及我許久未聯絡的高中同學竟然都是從 School 畢業的校友，這時當然不能浪費這麼好的弱連結，立馬請教他們當初在申請以及面試大致上是怎麼準備的，如果沒有認識的人，直接留言給撰寫文章的分享者，相信大家都會很願意提供協助的。 得到書審資料可能會問的問題(情報)後，再來就是好好爬梳自己的動機了，在決定想要轉職前有沒有先了解業界生態或是上線上課確認自己是否適合，我自己在申請前買了線上課程自學了三個月左右，不敢說自己對程式有 100%的熱情，但我對於程式可以解決的事情相當感興趣，所以這個階段我告訴自己只要學程式這件事沒有超出我的理解範圍，我不會一想到要寫作業解題就崩潰的話，那很值得試試看，出乎意料的，自學的這段時間讓我回想起高中最喜歡的數學(對，我是喜歡數學的文組生)，每個人的動機都不同，只要你能胸有成竹地說出來，相信就是成功的開始。 在官網開放報名後最長大概有四週的時間可以準備，(分成兩梯次各兩週時間) 期間 AppWorks School 會開一到兩場說明會大致講解課程內容以及請畢業約一年的校友來分享在 School 的生活以及工作後的情形， 如果對於課程有問題都可以在說明會提出。 可以更好的部分面試完我大概低落了三天，因為覺得自己沒有回答好，以下是我當時的反思： 沒有上網爬文企業面試的分享文（因為覺得 AppWorks School 是培訓班，但忘了他也同時是一間公司啊！） 室友是人資，卻沒有請他幫我模擬面試（原因是因為隔天要面試了很緊張，不想要前一晚又來個模擬面試搞得自己緊張兮兮） 面試到一半網路 Lag 大概一分鐘！（但這有點無解，因為住在人口超稠密的永和又逢疫情期間大家居家上課，電信業者說因為跟大家時間卡在一起所以網路可能會卡） 在申請表單送出之後其實我是蠻有信心的，因為我真的很真誠、用心的在回答，如果沒上，那我會沒有遺憾的去申請職訓局的青年補助方案，繼續往這條路邁進。 而幸運的在申請後一週獲得面試邀約，因為疫情的關係一律線上面試，大家真的要找網路好一點的地方，因為每位面試者時間只有 20 分鐘，如果因為網路問題斷線損失的會是自己的時間。面試官是 School 的校長和另一位校務人員，主要都是校長在發問。而面試的問題其實與一般企業面試的問題蠻像的，不外乎是轉職的動機、曾經經歷過的挫折、最想改進自己的部分等，再來就是在自學程式期間遇到的問題、為什麼你覺得自己適合當工程師，最後幾題我覺得自己回答得不好，也許是因為先前沒有準備到這類的題目，所以建議大家在面試前可以找朋友幫你進行模擬面試，畢竟自己預設的面試題目總會侷限在某個框架內，即便朋友不是人資，但不妨可以請朋友問一些他曾經被問過的面試題目來進行模擬，相信會很有幫助的！ 以下是當初報名 Batch 14 時書審資料的問題，供有興趣的人參考 前面是填寫基本資料以及你想選哪個班級（Android、iOS、Front-End、Back-End、Data Engineering Class） Based on your answer in last question, why are you interested in that specific software development ? What have you done to expose yourself to it so far? Have you taught yourself anything before? Describe what you learned and how you approached it. What’s the biggest achievement (or the most challenging thing) in your life? And how did you make it ? What would your plan be in the following three years if you graduated from AppWorks School? Please describe the ideal picture of your life. Please answer the question in the link below.（為一題簡單的邏輯流程測驗，只要展現你的思考邏輯就好） Did you watch the recommended learning materials we provided? If yes, do you have any questions? 1-min Self-intro Video (Optional)","tags":["目標設定"],"categories":["轉職"]},{"title":"有趣的邏輯運算子","path":"/2024/05/02/有趣的邏輯運算子/","content":"有次在工作中使用 || 這個看似簡單的邏輯符號，卻忘記判斷會將之轉換為布林值，導致原本 0 是可以接受的，卻無法被返回，因此把幾個常用的邏輯運算子整理了一下 三元運算符（? … : …）語法：當 condition 為 真值 返回 exprIfTruecondition ? exprIfTrue : exprIfFalse 12345condition // 把計算結果當作條件的表達式exprIfTrue // 若 condition 的計算結果為真值（truthy），則執行此表達式exprIfFalse // 若 condition 的計算結果為真值（falsy），則執行此表達式// falsy\\*\\*假值：null、NaN、0、空字串(&quot;&quot;)、undefined e.g. 12345678910111213141516171819202122232425262728const aa = 0console.log(&quot;1&quot;, aa ? aa : 1)//1,因為 0 為 falsy`條件鏈雖然很少這樣寫，不過竟然可以寫得跟 if…else 的情境一樣function example() &#123;return condition1 ? value1 : condition2 ? value2 : condition3 ? value3 : value4;&#125;等於以下function example() &#123;if (condition1) &#123; return value1;&#125; else if (condition2) &#123; return value2;&#125; else if (condition3) &#123; return value3;&#125; else &#123; return value4;&#125;&#125; 邏輯或（||）語法：如果 expr1 為真值，則返回 expr1；否則返回 expr2expr1 || expr2 邏輯與（&amp;&amp;）語法：一遇到假值就返回，如果都是真值則返回最後一個值expr1 &amp;&amp; expr2 1234result = &quot;&quot; &amp;&amp; &quot;foo&quot;; // 结果被赋值为 &quot;&quot;（空字串為 falsy ）result = 2 &amp;&amp; 0; // 结果被赋值为 0result = 0 &amp;&amp; 2; // 结果被赋值为 0result = &quot;foo&quot; &amp;&amp; 4; // 结果被赋值为 4 空值合併運算符（??）語法：只有在 leftExpr 是 null 或 undefined 的時候會返回 rightExprleftExpr ?? rightExpr || 的陷阱 1234567let count = 0;let text = &quot;&quot;;let qty = count || 42;let message = text || &quot;hi!&quot;;console.log(qty); // 42，而不是 0console.log(message); // &quot;hi!&quot;，而不是 &quot;&quot; ?? 實際應用 1234567let myText = &quot;&quot;; // An empty string (which is also a falsy value)let notFalsyText = myText || &quot;Hello world&quot;;console.log(notFalsyText); // Hello worldlet preservingFalsy = myText ?? &quot;Hi neighborhood&quot;;console.log(preservingFalsy); // &#x27;&#x27; (as myText is neither undefined nor null) 資料參考三元運算符 邏輯或（||） 邏輯與（&amp;&amp;） 空值合併運算符（??）","categories":["JS"]},{"title":"雲裡的日子","path":"/2024/04/23/雲裡的日子/","content":"關於我愛上雲林的那些小事。 你有去過雲林嗎？很多人的第一反應是：「咦～好像沒有耶？是在南部還是中部啊？」。 如果你去過劍湖山遊樂世界、王子大飯店，喝過古坑咖啡、吃過北港來的花生，那你就有那麼一點點認識雲林了。 記得大學面試時搭了好久的客運到雲林 (對，拿時還沒有高鐵)，一到學校就覺得這地方真「大」，馬路這麼大、太陽這麼大、樹這麼大，就連天空也這麼大。大學四年就讀雲科大設計系，因為課業實在繁忙，大家週末常常都得待在學校做作業，不過也因為這般的忙碌，我們常常在忙完作業的凌晨跑去火車站吃炒飯喝蛤蜊湯(一定要吃火車站走出來左手邊第二家)、或是在無法回家的跨年夜大夥兒騎車到劍湖山看煙火，許許多多的回憶聯繫著我們與小斗六，明明大家都不是本地人，說起雲林就好像自己的第二個家鄉一樣。於是在加入 TFT 後要選填到偏鄉服務的地區時，我毫無懸念的填了雲林，然後我回來了。 兩年的教書生涯，讓我不得不更愛雲林多一點。是因為學生家長會在來接小孩放學時將一大袋花生交給你說：「老蘇，給你棉吃啦～」(台灣國語是一定要的！)；是因為家長會在重要節日邀你去家裡辦桌；是因為家長會說：「老師～他不乖你就給他打屁股沒關係喔」，「爸爸～現在沒有人在打屁股啦ＸＤ」(而且我也不想打他屁股啊……)；也是因為去黃昏市場買菜時老闆娘都會多給我一小把蔥。 即使兩年前從雲林離開了，那裡也是一個我永遠會想「回去」的地方，因為那兒有曾經一起奮鬥的夥伴、有最好吃的越南麵包，以及最純真的笑聲。 你呢？有沒有一個地方總是讓你心心念念呢？ 三年後，當初小一的孩子今年都已經上國一了，記得去年參加他們的畢業典禮哭得唏哩花啦，除了替他們開心，當然還有一點點的感慨，曾經整天追著我跑的兩個小孩，如今已經成為靦腆的少年了，我們之間更是多了一份近鄉情卻，我知道為了我們之間應該就只能維持這樣淡淡的關係，但是沒關係，曾經參與你們部分的成長過程，33 老師已經心滿意足了：）","tags":["TFT"],"categories":["生活"]},{"title":"《12週做完一年工作》讀後心得：拋棄年度計畫吧！","path":"/2024/02/24/《12週做完一年工作》讀後心得：拋棄年度計畫吧！/","content":"我們大多數人都有兩種人生：我們所過的人生，和我們有能力去過的人生 為什麼想讀這本書？因為每年都會制定新年計劃，但都發現自己的年度計劃完成度不理想，甚至有些目標蟬聯了三年，剛好在 2023 年底透過薑餅資的 youtube 認識了這本書，而我也以書中建議的方法計畫了第一個十二週計畫，希望在年底回顧時能有所收獲。 心態：如果你想知道未來是什麼樣子，看看你的行動，它們是對未來最好的預測書中前半部不停地提及執行的重要性，作者提到：「你肯定聽過「知識就是力量」這句話，但我不同意。只有你去使用他，根據知識採取行動，知識才有力量。」 當然不是說『知識不是力量』，而是在提醒我們，當我們想要達成一件具體目標，我們可能需要知識引領我們，當我們朝著這個方向去行動時，「目標」才得以完成。 我在讀到這段的時候，想起了想要開始撰寫讀書筆記的初衷，因為自己有陣子很愛買書，甚至會在著迷一個主題時同時買了三本書，但最後都沒有看完，或是看了很多，但下次跟朋友聊起這本書時卻根本想不起來內容在說什麼，好像誤把「擁有」當成「掌握」，但卻沒有應用在現實生活中，這樣僅僅是心裡獲得了「好像讀了很多書」的安慰，實際上卻沒有優化自己的真實人生。 Brian P. Moran 提到：「如果你想知道未來是什麼樣子，看看你的行動，它們是對未來最好的預測」，這樣的觀念也很類似於一句英文俗諺：「You are what you eat」， 意思是你吃什麼，食物給予的營養或熱量，就會反應在我們的身體與容貌上。因此，當我們感覺自己離理想中的自己有所距離時，不妨細看一天之中所投入的時間和行動，透過這樣的自我觀察，我們能更明確地認識自己，並針對性地調整行為，走向更為符合理想的未來。 工具：根據以下的方法打造第一個 12 週計劃吧！ 願景 而書中提到的建立 12 週計畫的方式，需要先從願景開始，因為一個令人信服的個人願景會激發熱情，透過制定人生、三年願景、一年願景，再將一年的目標拆分到四個十二週中 規劃 量化或質化你的目標，使它是具體且可衡量的，比如打多少通電話、減多少公斤……等，並且設定時間限制 追蹤管理 如果沒有架構和環境的支持，堅持到底就會成為一場對意志力的長期考驗，所以將你的 12 週計劃再分給每一週吧！規劃你的每一週，並找到一個夥伴，在每週結束時你們可以向對方分享這週進行的成果，並互相鼓勵，以及討論沒有達成的原因 評量 「你的週評量卡是最能準確預測你的未來的水晶球。如果你每一天、每一週都能忠實地完成關鍵行動，成功就是會來」-Brian P. Moran 書中提到評量可關注的兩種指標，一個是「領先指標」，即每週的執行力，你有機會調整，而不是到 12 週過完才能確認有無達到；另一個是「落後指標」，即 12 週後的結果，作者鼓勵我們要關注領先指標，因為關注行動多過關注結果，你對自身行動的掌控力比對結果的掌控要大 分配時間 在閒暇時間做些讓你身心舒適的事，只要適度，無疑是健康的，但是當我們始終選擇舒適，就註定了人生將遠遠達不到我們本該能達到的高度 再自己的每週計畫中分別放入這三個時間塊： 策略時間塊 此時間塊可能需要 1-2 小時，主要用來安排你下週的計劃，再回頭看看你的願景，與願景重新連結，以及回顧你當週的 12 週計劃，績效如何？是否遇到執行問題？ 緩衝時間塊 每天安排 30 分鐘處理低層次的活動，像是記帳、回復信件等瑣碎的事…… 抽離時間塊 每週可以安排 3 小時的空白時間，用來避免倦怠，並創造更多自由時間 當責 留意自己在什麼時候找藉口，什麼時候甘於平庸，為了實現願景，就要掌握自己的思想、行動和結果，如果想要不同的結果，就要用不同的方式做事 承諾 根據承諾採取行動，而不是憑感覺，書中提及一個例子：「失敗與墜落兩者的差異很微妙，卻是世界上最大的不同。在墜落中，你還沒有搆到目標，但是你絕不會放手；在墜落中你會跌倒，但在失敗中你會放手。墜落意味著你全力以赴向上攀登—即使成功的機率不到 20%、10%甚至 5%。你毫無保留，什麼精神或身體的資源都用上了。在墜落中，你不會在心理上給自己找退路：『好吧，我並沒有真正全力以赴。……如果我盡了全力，我可能會成功。』在墜落中，儘管有恐懼、痛苦、乳酸和不確定性，你始終全力以赴。在外界看來，失敗和墜落看起來相似（在這兩種情況下，你都是飛在半空中），但是墜落的內心感受完全不同於失敗的內心感受」，唯有在墜落而非失敗的時候，你才能發現自己真正的極限所在，承諾的定義是要求你「嘗試去墜落，而不是嘗試失敗 」。現在就在你腦中設定：過程比結果更重要 卓越的當下 縮小你對改變的感知，就像原子習慣，把想做的事阻力變小，你對改變幅度的看法就會改變，進而讓你更容易開始行動 結語很喜歡書中的一些精神喊話，雖然很雞湯，但很實在的激勵著我，不知道看完後你是否也想著手進行自己的第一個 12 週計劃呢？我也還在嘗試的路上，期待之後可以再寫篇文章分享我實踐後的心得。","tags":["目標設定"],"categories":["閱讀心得"]},{"title":"The Power of Yet , 「還沒」的力量","path":"/2021/09/25/還沒的力量/","content":"每個行動都是一張選票，投給你想成為的人吧！ _原子習慣 轉眼好久沒發文了，AppWorks School 開學至今接近兩個月了，這段時間每天有寫不完的代碼、想不完的邏輯與除不完的錯，心情也隨著作業完成的狀態而起起伏伏。一直以來我給人的印象是「正面、積極、樂觀」，朋友都形容我是個 doer，想到什麼事情會立馬去做，從劇場到教育界，從設計師轉戰工程師，曾經我也以為我是個「我能感」很高的人，直到最近為了轉職而進修，才讓我認識自己更深一點。 求學階段因為成績不錯，常常成為家人茶餘飯後聊(炫)天(耀)的話題，成就感完全來自於長輩的讚美，活在以成績定義的掌聲中；出社會後，沒有成績可以定義我了，但我還是想尋求「完美」的標籤往自己身上貼，漸漸的我發現，完美主義實際上阻礙了我做好多事，喜歡畫畫，卻因為擔心畫不好而選擇放下畫筆、想要練習寫文章，卻也往往在打完草稿後覺得不夠好而選擇刪除，而現在在學習寫程式的路上，看著同學寫出漂亮的邏輯判斷，我開始自我懷疑，覺得自己可能高估了自己的腦袋瓜，開始否定自己、覺得自己就是學不會……而這樣的思維，就是標準的固定型思維啊！ 固定型思維 (Fixed mindset)與成長型思維 (Growth mindset)是由史丹佛大學學者 Carol Dweck 在教育心理研究中提出的兩種心態模式，固定型思維的人就像舊式手機，覺得自己天生就配備了某種程度的硬體，如果已經到達了硬體條件的上限，便無法成長，因為害怕做得不好，而不敢挑戰困難的事物；而成長型思維的人就像智慧型手機，相信自己可以透過軟體更新來優化自己，\b 而也更願意接受可能會導致犯錯、但會讓人成長的任務。 發現到這個令人有點難過的事實其實讓我挺開心的(?)，至少我有更了解自己一點。 我想要成為勇於接受挑戰的人因此我想要嘗試調整自己的心態，就從說「還沒」開始吧！我不是學不會，是「還沒學會」，我不是做不到，是「還沒做到」！","tags":["自我覺察","成長型思維"],"categories":["生活"]},{"title":"你好，我是33","path":"/about/index.html","content":"我們大多數人都有兩種人生：我們所過的人生，和我們有能力去過的人生-The 12 week year Hi，我是 33，想要透過書寫習慣的養成幫助自己整理腦中思緒 跨領域設計研究所畢業，當過劇場工作者、TFT 偏鄉教師、建築照明設計師，兩年前輾轉成為了前端工程師。很多人問我，會不會後悔走了這麼多條路最後才找到自己想做的事？ 我的答案是不會，雖然對於資工畢業的本科生來說，同樣年紀的他們可能都已經成為了某個 Domain 的小組長，但是我很慶幸在勇氣滿載的 20+ 做了這麼多嘗試，劇場工作者的自由讓我養成自律的習慣；偏鄉老師讓我知道生命足以影響生命；而建築照明設計與不同業主、廠商開會讓我練習最多的溝通技巧。 而現在，我是一名前端工程師，轉職後的前兩年，我還在冒牌者症候群的陰影下，實在沒辦法很有自信及開心的在工作上展現，而兩年後的今天，我終於可以說，我其實還蠻享受這份工作的，很像我同樣喜歡的懸疑片，一步步的去思考解答；也很像高中時的數學題，有很多不同的解法，但只要解的出來就是好解法 閱讀筆記平時喜歡看書，也買了很多書，但卻發現自己常常看完就忘，或是看得當下深受感動，跟朋友聊起時卻發現也沒有將書中學到的方法實際運用在生活上，總之希望自己能有條理的整理看完書的一點 take away，真正將資訊轉化為知識：），於是開始有了做筆記的想法 ⬇⬇⬇目前是使用 Heptabase 來管理專業知識上想要研究的主題，以及把自己想做的事當成專案來規劃，選擇 Heptabase 原因之一是當初在使用 Notion 時發現自己對於埋得很深的筆記（太多層級）會很難找到，而 Hepta 可以把目前關心的主題都當成一個個白板，而我可以很一目瞭然的管理所有我所關心的事 關於身體喜歡運動，在還可以大口呼吸跑步的 2020 達成自己半程馬拉松身的小小目標，而目前一週雖然只跑一次，還是想持續保持。又，為一個容易緊張的處女座，我透過瑜伽及冥想及閱讀，希望自己能夠練習更加專注，成為一個內心強大的人"}]